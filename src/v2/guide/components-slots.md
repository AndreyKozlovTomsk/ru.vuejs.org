---
title: Слоты
type: guide
order: 104
---

> Подразумевается, что вы уже изучили и разобрались с разделом [Основы компонентов](components.html). Если нет — прочитайте его сначала.

> В версии 2.6.0, мы представили новый единый синтаксис (директива `v-slot`) для именованных слотов и слотов с ограниченной областью видимости. Он заменяет атрибуты `slot` и `slot-scope`, которые в настоящий момент считаются устаревшими, но _не_ были удалены и документированы [здесь](#Deprecated-Syntax). Обоснование введения нового синтаксиса описано в этом [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md).

## Содержимое слота

Vue реализует API распределения контента, которое вдохновлено текущим [черновиком спецификации веб-компонентов](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md), используя элемент `<slot>` в качестве точек распространения контента.

Например, это позволяет вам составлять такие компоненты:

``` html
<navigation-link url="/profile">
  Ваш профиль
</navigation-link>
```

Для этого в шаблоне `<navigation-link>` у вас должно быть:

``` html
<a
  v-bind:href="url"
  class="nav-link"
>
  <slot></slot>
</a>
```

При отрисовке компонента `<slot></slot>` будет заменён на «Ваш профиль». Слоты могут содержать любой код шаблона, включая HTML:

``` html
<navigation-link url="/profile">
  <!-- Добавляем иконку из набора Font Awesome -->
  <span class="fa fa-user"></span>
  Ваш профиль
</navigation-link>
```

Или даже другие компоненты:

``` html
<navigation-link url="/profile">
  <!-- Используем компонент для добавления иконки -->
  <font-awesome-icon name="user"></font-awesome-icon>
  Ваш профиль
</navigation-link>
```

Если шаблон `<navigation-link>` **не содержит** элемент `<slot>`, любой переданный контент будет просто проигнорирован.

## Область видимости при компиляции

Когда необходимо использовать данные внутри слота, например:

``` html
<navigation-link url="/profile">
  Вы вошли как {{ user.name }}
</navigation-link>
```

Этот слот имеет доступ к тем же свойствам экземпляра (т.е. к той же «области видимости»), что и остальная часть шаблона. Слот **не имеет** доступа к области видимости `<navigation-link>`. Поэтому попытка получить значение `url` не сработает:

``` html
<navigation-link url="/profile">
  Кликните для перехода сюда: {{ url }}
  <!--
  Значение `url` будет неопределено (undefined), потому что этот
  контент передается _на_ <navigation-link>, а не определён
  _внутри_ компонента <navigation-link>.
  -->
</navigation-link>
```

Как правило, помните что:

> Всё в родительском шаблоне компилируется в области видимости родительского компонента; всё в дочернем шаблоне компилируется в области видимости дочернего компонента.

## Содержимое слота по умолчанию

Бывают случаи, когда полезно указать запасное (т.е. по умолчанию) содержимое слота, которое будет отображаться только тогда, когда ничего не передавалось в слот. Например, в компоненте `<submit-button>`:

```html
<button type="submit">
  <slot></slot>
</button>
```

Мы могли бы захотеть, чтобы текст «Отправить» отображался внутри `<button>` большую часть времени. Чтобы сделать текст «Отправить» в качестве содержимого по умолчанию, мы можем поместить его между тегами `<slot>`:

```html
<button type="submit">
  <slot>Отправить</slot>
</button>
```

Теперь, когда мы используем `<submit-button>` в родительском компоненте, не предоставив содержимое для слота:

```html
<submit-button></submit-button>
```

отобразится содержимое по умолчанию, «Отправить»:

```html
<button type="submit">
  Отправить
</button>
```

Но если указать содержимое:

```html
<submit-button>
  Сохранить
</submit-button>
```

Тогда предоставленное содержимое будет использовано для отображения:

```html
<button type="submit">
  Сохранить
</button>
```

## Именованные слоты

> Обновлено в версии 2.6.0+. [См. здесь](#Deprecated-Syntax) устаревший синтаксис с использованием атрибута `slot`.

Часто бывает удобно иметь несколько слотов. Например, в компоненте `<base-layout>` со следующим шаблоном:

``` html
<div class="container">
  <header>
    <!-- Мы хотим отобразить контент заголовка здесь -->
  </header>
  <main>
    <!-- Мы хотим отобразить основной контент здесь -->
  </main>
  <footer>
    <!-- Мы хотим отобразить контент подвала здесь -->
  </footer>
</div>
```

Для таких случав элементу `<slot>` можно указать специальный атрибут `name`, который используется для определения дополнительных слотов:

``` html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

Обычный `<slot>` без `name` неявно имеет имя "default".

Чтобы предоставить содержимое для именованных слотов, нужно использовать директиву `v-slot` на `<template>`, указав имя слота аргументом `v-slot`:

```html
<base-layout>
  <template v-slot:header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <p>Параграф для основного контента.</p>
  <p>И ещё один.</p>

  <template v-slot:footer>
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

Теперь всё внутри элементов `<template>` будет передаваться в соответствующие слоты. Предполагается, что любое содержимое, не обернутое в `<template>` с использованием `v-slot`, предназначается для слота по умолчанию.

Однако, можно явно обернуть содержимое слота по умолчанию в `<template>`:

```html
<base-layout>
  <template v-slot:header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <template v-slot:default>
    <p>Параграф для основного контента.</p>
    <p>И ещё один.</p>
  </template>

  <template v-slot:footer>
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

В любом случае, отрисованный HTML будет таким:

``` html
<div class="container">
  <header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </header>
  <main>
    <p>Параграф для основного контента.</p>
    <p>И ещё один.</p>
  </main>
  <footer>
    <p>Некая контактная информация</p>
  </footer>
</div>
```

Обратите внимание, что **`v-slot` можно добавлять только на `<template>`** (с [одним исключением](#Abbreviated-Syntax-for-Lone-Default-Slots)), в отличие от устаревшего [атрибута `slot`](#Deprecated-Syntax).

## Слоты с ограниченной областью видимости

> Обновлено в версии 2.6.0+. [См. здесь](#Deprecated-Syntax) устаревший синтаксис, с использованием атрибута `slot-props`.

Иногда для содержимого слота полезно иметь возможность использовать данные, доступные только в дочернем компоненте. Например, представьте компонент `<current-user>` со следующим шаблоном:

```html
<span>
  <slot>{{ user.lastName }}</slot>
</span>
```

Может потребоваться заменить это содержимое по умолчанию, чтобы отобразить имя пользователя, а не фамилию, например:

``` html
<current-user>
  {{ user.firstName }}
</current-user>
```

Однако это не сработает, потому что только компонент `<current-user>` имеет доступ к `user`, а новое содержимое отрисовывается в родительском.

Чтобы сделать `user` доступным для содержимого слота в родительском компоненте, мы можем добавить привязку `user` в качестве атрибута на элементе `<slot>`:

``` html
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>
```

Атрибуты, привязанные к элементу `<slot>`, называются **входными параметрами слота**. Теперь, в родительской области видимости, можно использовать `v-slot` со значением, чтобы определить имя для предоставленных слоту входных параметров:

``` html
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>
```

В этом примере мы выбрали имя объекта `slotProps`, содержащего все наши входные параметры слота, но вы можете использовать любое имя, которое вам нравится.

### Сокращённый синтаксис для одиночного слота по умолчанию

В случаях, подобных описанным выше, когда _только_ слоту по умолчанию предоставляется содержимое, тег компонента может использоваться в качестве шаблона слота. Это позволяет нам использовать `v-slot` непосредственно на компоненте:

``` html
<current-user v-slot:default="slotProps">
  {{ slotProps.user.firstName }}
</current-user>
```

Это можно сократить ещё больше. Точно также, как предполагается, что неуказанное содержимое относится к слоту по умолчанию, `v-slot` без аргумента должен ссылаться на слот по умолчанию:

``` html
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
</current-user>
```

Обратите внимание, что сокращённый синтаксис для слота по умолчанию **нельзя смешивать** с именованными слотами, так как это приведёт к неоднозначности области видимости:

``` html
<!-- НЕПРАВИЛЬНО, будет выкидывать предупреждение -->
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
  <template v-slot:other="otherSlotProps">
    slotProps НЕДОСТУПНЫ здесь
  </template>
</current-user>
```

При наличии нескольких слотов используйте полный синтаксис на основе `<template>` для _всех_ слотов:

``` html
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>

  <template v-slot:other="otherSlotProps">
    ...
  </template>
</current-user>
```

### Деструктурирование входных параметров слота

Под капотом слоты с ограниченной областью видимости работают, заключая в себе содержимое слота в функции, передаваемой одним аргументом:

```js
function (slotProps) {
  // ... содержимое слота ...
}
```

Это означает, что значение `v-slot` может принимать любое допустимое выражение JavaScript, которое может появиться в позиции аргумента определения функции. Поэтому в поддерживаемых окружениях ([однофайловых компонентов](single-file-components.html) или [современных браузеров](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility)), вы также можете использовать [деструктурирование ES2015](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring) чтобы извлечь определённые входные параметры слотов, например вот так:

``` html
<current-user v-slot="{ user }">
  {{ user.firstName }}
</current-user>
```

Это позволит сделать шаблон намного чище, особенно когда слот предоставляет множество входных параметров. Это также открывает другие возможности, такие как переименование входных параметров, например `user` в `person`:

``` html
<current-user v-slot="{ user: person }">>
  {{ person.firstName }}
</current-user>
```

Вы даже можете определить значения по умолчанию, которые будут использоваться в случае, если входной параметр слота неопределён:

``` html
<current-user v-slot="{ user = { firstName: 'Guest' } }">>
  {{ user.firstName }}
</current-user>
```

## Динамическое имя слота

> Добавлено в версии 2.6.0+

[Динамические аргументы директивы](syntax.html#Динамические-аргументы) также работают с `v-slot`, позволяя указать динамическое имя слота:

``` html
<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
</base-layout>
```

## Сокращённая запись для именованных слотов

> Добавлено в версии 2.6.0+

Аналогично `v-on` и `v-bind`, `v-slot` также имеет собственное сокращение, заменяющее все перед аргументом (`v-slot:`) специальным символом `#`. Например, `v-slot:header` может быть записан как `#header`:

```html
<base-layout>
  <template #header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <p>Параграф для основного контента.</p>
  <p>И ещё один.</p>

  <template #footer>
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

Однако, как и в случае с другими директивами, сокращение доступно только при наличии аргумента. Это означает, что следующий синтаксис недопустим:

``` html
<!-- Это выкинет предупреждение -->
<current-user #="{ user }">
  {{ user.firstName }}
</current-user>
```

Вместо этого вы должны всегда указывать имя слота, если хотите использовать сокращение:

``` html
<current-user #default="{ user }">
  {{ user.firstName }}
</current-user>
```

## Другие примеры

**Входные параметры слотов позволяют превратить слоты в переиспользуемые шаблоны, которые могут отображать различное содержимое, основываясь на входных параметрах.** Это очень полезно при разработке переиспользуемого компонента, который инкапсулирует логику данных, позволяя родительскому компоненту настраивать часть своего шаблона.

Например, мы реализуем компонент `<todo-list>`, который содержит шаблон и логику фильтрации для списка:

```html
<ul>
  <li
    v-for="todo in filteredTodos"
    v-bind:key="todo.id"
  >
    {{ todo.text }}
  </li>
</ul>
```

Вместо жёсткого кодирования содержимого для каждой записи, мы можем позволить родительскому компоненту взять на себя управления отображением записей с помощью слота, а затем привязать `todo` в качестве входного параметра слота:

```html
<ul>
  <li
    v-for="todo in filteredTodos"
    v-bind:key="todo.id"
  >
    <!--
    У нас есть слот для каждой записи, передавая
    объект `todo` в качестве входного параметра слота.
    -->
    <slot name="todo" v-bind:todo="todo">
      <!-- Fallback content -->
      {{ todo.text }}
    </slot>
  </li>
</ul>
```

Теперь, когда мы используем компонент `<todo-list>`, мы можем опционально переопределить `<template>` для элементов списка, но сохранив доступ к данным от дочернего компонента:

```html
<todo-list v-bind:todos="todos">
  <template v-slot:todo="{ todo }">
    <span v-if="todo.isComplete">✓</span>
    {{ todo.text }}
  </template>
</todo-list>
```

Однако, это едва ли вершина айсберга того, на что способы слоты с ограниченной областью видимости. Несколько реальных примеров использования слотов с ограниченной областью видимости вы можете посмотреть в библиотеках [Vue Virtual Scroller](https://github.com/Akryum/vue-virtual-scroller), [Vue Promised](https://github.com/posva/vue-promised), и [Portal Vue](https://github.com/LinusBorg/portal-vue).

## Устаревший синтаксис

> Директива `v-slot` была представлена в Vue 2.6.0, предлагая улучшенный альтернативный API для всё ещё поддерживаемых атрибутов `slot` и `slot-scope`. Полное обоснование введения `v-slot` описано в этом [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md). Атрибуты `slot` и `slot-scope` будут поддерживаться во всех будущих новых версиях 2.x, но официально они считаются устаревшими и будут удалены во Vue 3.

### Именованные атрибуты с помощью атрибута `slot`

> <abbr title="Будет поддерживаться во всех 2.x версиях Vue, но больше не рекомендуется к использованию.">Устаревшее</abbr> с 2.6.0+. Новый рекомендованный синтаксис можно посмотреть [здесь](#Named-Slots).

Для передачи содержимого в именованные слоты из родительского компонента используйте специальный атрибут `slot` на теге `<template>` (в качестве примера здесь используется компонент `<base-layout>`, описанный [выше](#Named-Slots)):

```html
<base-layout>
  <template slot="header">
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <p>Параграф для основного контента.</p>
  <p>И ещё один.</p>

  <template slot="footer">
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

Также атрибут `slot` может использоваться непосредственно на обычном элементе:

``` html
<base-layout>
  <h1 slot="header">Здесь мог быть заголовок страницы</h1>

  <p>Параграф для основного контента.</p>
  <p>И ещё один.</p>

  <p slot="footer">Некая контактная информация</p>
</base-layout>
```

Может быть один слот без имени, который является **слотом по умолчанию** и служит для отображения оставшегося содержимого. В обоих случаях итоговый HTML будет таким:

``` html
<div class="container">
  <header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </header>
  <main>
    <p>Параграф для основного контента.</p>
    <p>И ещё один.</p>
  </main>
  <footer>
    <p>Некая контактная информация</p>
  </footer>
</div>
```

### Слоты с ограниченной областью видимости с помощью атрибута `slot-scope`

> <abbr title="Будет поддерживаться во всех 2.x версиях Vue, но больше не рекомендуется к использованию.">Устаревшее</abbr> с 2.6.0+. Новый рекомендованный синтаксис можно посмотреть [здесь](#Scoped-Slots).

Чтобы получить входные параметры, переданные в слот, родительский компонент может использовать `<template>` с атрибутом `slot-scope` (в качестве примера используется `<slot-example>`, описанный [выше](#Scoped-Slots)):

``` html
<slot-example>
  <template slot="default" slot-scope="slotProps">
    {{ slotProps.msg }}
  </template>
</slot-example>
```

Здесь `slot-scope` объявляет объект с полученными параметрами как переменную `slotProps`, и делает его доступным внутри области видимости `<template>`. Вы можете назвать `slotProps` как угодно, аналогично именованию аргументов функций в JavaScript.

В примере `slot="default"` может быть опущен, так как это подразумевается:

``` html
<slot-example>
  <template slot-scope="slotProps">
    {{ slotProps.msg }}
  </template>
</slot-example>
```

Атрибут `slot-scope` также может быть использован непосредственно не на элементах `<template>` (включая компоненты):

``` html
<slot-example>
  <span slot-scope="slotProps">
    {{ slotProps.msg }}
  </span>
</slot-example>
```

Значение `slot-scope` может принимать любое допустимое выражение JavaScript, которое может использоваться в позиции аргумента определения функции. Это означает, что в поддерживаемых средах ([однофайловых компонентов](single-file-components.html) или [современных браузерах](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility)) вы также можете использовать [деструктурирование ES2015](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring) в выражении, например так:

``` html
<slot-example>
  <span slot-scope="{ msg }">
    {{ msg }}
  </span>
</slot-example>
```

Используя `<todo-list>` описанный [выше](#Other-Examples) в качестве примера, вот эквивалентная запись с использованием `slot-scope`:

``` html
<todo-list v-bind:todos="todos">
  <template slot="todo" slot-scope="{ todo }">
    <span v-if="todo.isComplete">✓</span>
    {{ todo.text }}
  </template>
</todo-list>
```
