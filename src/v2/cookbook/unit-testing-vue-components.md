---
title: Модульное тестирование Vue-компонентов
type: cookbook
order: 6
---

## Простой пример

Модульное тестирование - фундаментальная часть разработки программного обеспечения. В модульных тестах выполняются небольшие фрагменты (единицы) кода в изоляции для упрощения добавления новых функциональных возможностей и отслеживания ошибок. [Однофайловые компоненты](../guide/single-file-components.html) Vue позволяют просто писать модульные тесты для компонентов в изоляции. Это поможет вам разрабатывать новую функциональность с уверенностью, что вы не ломаете работу существующей, и помогает другим разработчикам понять, как работает компонент.

Этот простой пример проверяет, отрисовывается ли какой-либо текст:

```html
<template>
  <div>
    <input v-model="username">
    <div 
      v-if="error"
      class="error"
    >
      {{ error }}
    </div>
  </div>
</template>

<script>
export default {
  name: 'Привет',
  data () {
    return {
      username: ''
    }
  },

  computed: {
    error () {
      return this.username.trim().length < 7
        ? 'Введите более длинное имя пользователя'
        : ''
    }
  }
}
</script>
```

```js
import { shallowMount } from '@vue/test-utils'

test('Foo', () => {
  // отрисовать компонент
  const wrapper = shallowMount(Hello)

  // не разрешено для `username` меньше 7 символов, без учёта пробелов
  wrapper.setData({ username: ' '.repeat(7) })

  // проверить, что ошибка отрисовалась
  expect(wrapper.find('.error').exists()).toBe(true)

  // обновить имя, чтобы оно было достаточно длинным
  wrapper.setData({
    username: 'Александр'
  })

  // проверяем, что ошибка исчезла
  expect(wrapper.find('.error').exists()).toBe(false)
})
```

Вышеприведённый фрагмент кода показывает, как проверить, отрисовывается ли сообщение в зависимости от длины имени пользователя. Он демонстрирует общую идею модульного тестирования Vue-компонентов: отрисовка компонента и проверка, что разметка соответствует состоянию компонента.

## Зачем тестировать?

У модульных тестов компонентов есть множество преимуществ:

- Предоставляет документацию, как должен работать компонент
- Экономит время на ручное тестирование
- Уменьшает баги при реализации новой функциональности
- Улучшает дизайн кода
- Способствует рефакторингу кода

Автоматическое тестирование позволяет большим командам разработчиков поддерживать сложную кодовую базу.

#### Начало работы

[Vue Test Utils](https://github.com/vuejs/vue-test-utils) - официальная библиотека для модульного тестирования Vue-компонентов. Шаблон `webpack` [vue-cli](https://github.com/vuejs/vue-cli) идёт в комплекте с Karma или Jest, как с хорошо поддерживаемыми исполнителями тестов (test runners), и есть некоторые [руководства](https://vue-test-utils.vuejs.org/guides/) в документации Vue Test Utils.

## Пример из реального мира

Модульные тесты должны быть:

- Быстрыми для выполнения
- Простыми для понимания
- Тестировать только _единственный участок функциональности_

Давайте продолжим работу с предыдущим примером, представив идею <a href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)">фабричной функцию</a>, чтобы сделать наш тест более компактным и читаемым.  Компонент должен:

- показать приветствие 'Добро пожаловать в книгу рецептов Vue.js'.
- попросить пользователя ввести своё имя пользователя
- показать ошибку, если введённое имя пользователя меньше семи символов

Давайте сначала рассмотрим код компонента:

```html
<template>
  <div>
    <div class="message">
      {{ message }}
    </div>
    Введите имя пользователя: <input v-model="username">
    <div 
      v-if="error"
      class="error"
    >
      Пожалуйста, введите имя пользователя длиной не менее семи символов.
    </div>
  </div>
</template>

<script>
export default {
  name: 'Foo',

  data () {
    return {
      message: 'Добро пожаловать в книгу рецептов Vue.js',
      username: ''
    }
  },

  computed: {
    error () {
      return this.username.trim().length < 7
    }
  }
}
</script>
```

Список из того, что нам нужно проверить:

- отрисовалось ли свойство `message`?
- если `error` равно `true`, в разметке должен быть `<div class="error">`
- если `error` равно `false`, в разметке не должно быть `<div class="error">`

И наша первая попытка теста:

```js
import { shallowMount } from '@vue/test-utils'

describe('Foo', () => {
  it('отрисовывает сообщение и правильно реагирует на пользовательский ввод', () => {
    const wrapper = shallowMount(Foo, {
      data: {
        message: 'Привет, мир',
        username: ''
      }
    })

    // посмотреть, отрисовалось ли сообщение
    expect(wrapper.find('.message').text()).toEqual('Привет, мир')

    // проверить, что ошибка отрисовалась
    expect(wrapper.find('.error').exists()).toBeTruthy()

    // обновить `username` и проверить, что ошибка больше не отрисовалась
    wrapper.setData({ username: 'Александр' })
    expect(wrapper.find('.error').exists()).toBeFalsy()
  })
})
```

Есть несколько проблем с вышеприведённым кодом:

- в одном тесте проверяются сразу много чего
- трудно определить различные состояния компонента, и что должно отрисовываться

В примере ниже тестирование улучшается с помощью следующих правил:

- один блок `it` содержит только один вызов `expect`
- наличие краткого и чёткого описания для каждого теста
- предоставление только минимальных данных, требуемых для выполнения теста
- рефакторинг дублирования логики (создание `wrapper` и установка переменной `username`) в фабричную функцию

*Updated test*:
```js
import { shallowMount } from '@vue/test-utils'
import Foo from './Foo'

const factory = (values = {}) => {
  return shallowMount(Foo, {
    data: { ...values  }
  })
}

describe('Foo', () => {
  it('отрисовывает приветственное сообщение', () => {
    const wrapper = factory()

    expect(wrapper.find('.message').text()).toEqual('Добро пожаловать в книгу рецептов Vue.js')
  })

  it('отрисовывает ошибку, когда имя пользователя меньше 7 символов', () => {
    const wrapper = factory({ username: '' })

    expect(wrapper.find('.error').exists()).toBeTruthy()
  })

  it('отрисовывает ошибку, когда имя пользователя состоит только из пробелов', () => {
    const wrapper = factory({ username: ' '.repeat(7) })

    expect(wrapper.find('.error').exists()).toBeTruthy()
  })

  it('не отрисовывает ошибку, когда имя пользователя равно 7 символам или более', () => {
    const wrapper = factory({ username: 'Александр' })

    expect(wrapper.find('.error').exists()).toBeFalsy()
  })
})
```

Следует отметить:

В верхней части мы объявляем фабричную функцию, когда объединяет объект `values` в свойство `data` и возвращает новый экземпляр `wrapper`. Таким образом, нам не нужно дублировать `const wrapper = shallowMount(Foo)` в каждом тесте. Ещё одно преимущество для этого - когда более сложные с методом или вычисляемым свойством, которые вы, возможно, имитировать (mock) или создать заглушку (stub) в каждом тесте, вам нужно объявить его только один раз.

## Дополнительный контекст

Вышеприведённый тест довольно прост, но на практике у Vue-компонентов часто другое поведение, которые вы хотите проверить, например:

- вызовы к API
- совершение или отправка мутаций или действий с хранилищем `Vuex`
- тестирования взаимодействия

Более подробные примеры, показывающие такие тесты в действии, вы можете найти в [руководствах](https://vue-test-utils.vuejs.org/guides/).

Vue Test Utils и огромная экосистема JavaScript обеспечивают множество инструментов для обеспечения почти 100% покрытия тестирования. Однако модульные тесты являются лишь частью пирамиды тестирования. Некоторые другие типы тестов, включая тесты e2e (end-to-end) и тесты снапшотами. Модульные тесты - это самые маленькие и самые простые тесты - они проверяет утверждения на маленьких единицах работы, изолируя каждую часть единственного компонента.

Тесты снимков (snapshot) сохраняют разметку вашего Vue-компонента и сравниваются с новым, созданным при каждом выполнении теста. Если что-то изменяется, разработчик будет в курсе и сможет решить, было ли решение намеренным (компонент был обновлён) или случайным (компонент работает некорректно).

Тесты end-to-end гарантирует, что несколько компонентов хорошо взаимодействуют друг с другом. Они находятся на более высоком уровне. Примерами таких тестов может быть тестирование регистрации, входа и изменения данных у пользователя. Они работают медленнее, чем модульные тесты или тесты снимками.

Модульные тесты наиболее полезны во время разработки, либо чтобы помочь разработчику подумать спроектировать компонент, либо отрефакторить существующий компонент. Они запускаются каждый раз при изменении кода.

Тесты высокого уровня, такие как end-to-end тесты, работают намного медленнее. Обычно они запускают перед деплоем для гарантии, что каждая часть системы работает корректно.

Более подробную информацию о тестировании Vue-компонентов вы можете найти в книге [Testing Vue.js Applications](https://www.manning.com/books/testing-vuejs-applications) от члена команды [Эдда Йербурга](https://eddyerburgh.me/).

## Когда не следует тестировать

Модульное тестирование - важная часть любого серьёзного приложения. Сначала, когда версия приложения остаётся неясной, модульное тестирование может замедлить разработку, но после стабилизации версии и настоящие пользователи будут взаимодействовать с приложением, модульные тесты (и другие типы автоматических тестов) абсолютно необходимы для обеспечения удобства в поддержке и масштабируемости кодовой базы.
